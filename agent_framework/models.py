"""Core data models using Pydantic for runtime validation and immutability."""

from typing import Optional, Dict, Any, Literal
from datetime import datetime
from pydantic import BaseModel, Field, field_validator


class Signal(BaseModel):
    """Trading signal generated by an agent.
    
    Uses Pydantic for automatic validation and immutability.
    """
    direction: Literal['bullish', 'bearish', 'neutral']
    confidence: float = Field(ge=0.0, le=1.0)
    reasoning: str = Field(min_length=1)
    timestamp: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    model_config = {
        'frozen': True,  # Immutability
        'str_strip_whitespace': True,
    }


class LLMConfig(BaseModel):
    """Configuration for LLM providers with validation.
    
    Supports system prompts for agent personas.
    """
    provider: Literal['openai', 'anthropic', 'ollama']
    model: str = Field(min_length=1)
    api_key: Optional[str] = None
    base_url: Optional[str] = None  # For Ollama
    temperature: float = Field(default=0.7, ge=0.0, le=2.0)
    max_tokens: int = Field(default=1000, gt=0)
    system_prompt: Optional[str] = None  # Agent persona
    max_retries: int = Field(default=3, ge=0, le=10)
    timeout: int = Field(default=60, gt=0)
    
    model_config = {
        'frozen': True,
    }


class RAGConfig(BaseModel):
    """Configuration for RAG system."""
    chunk_size: int = Field(default=500, gt=0)
    chunk_overlap: int = Field(default=50, ge=0)
    top_k: int = Field(default=3, gt=0)
    embedding_model: str = Field(default="sentence-transformers/all-MiniLM-L6-v2")
    
    model_config = {
        'frozen': True,
    }
    
    @field_validator('chunk_overlap')
    @classmethod
    def validate_overlap(cls, v: int, info) -> int:
        """Ensure overlap is less than chunk size."""
        if 'chunk_size' in info.data and v >= info.data['chunk_size']:
            raise ValueError("chunk_overlap must be less than chunk_size")
        return v


class AgentConfig(BaseModel):
    """Complete agent configuration."""
    name: str = Field(min_length=1)
    description: str
    llm: Optional[LLMConfig] = None
    rag: Optional[RAGConfig] = None
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
    model_config = {
        'frozen': True,
    }


class DatabaseConfig(BaseModel):
    """Database configuration with validation."""
    connection_string: str = Field(min_length=1)
    min_pool_size: int = Field(default=2, ge=1)
    max_pool_size: int = Field(default=10, gt=0)
    command_timeout: int = Field(default=60, gt=0)
    max_queries: int = Field(default=50000, gt=0)
    max_inactive_connection_lifetime: float = Field(default=300.0, gt=0)
    
    model_config = {
        'frozen': True,
    }
    
    @field_validator('max_pool_size')
    @classmethod
    def validate_pool_size(cls, v: int, info) -> int:
        """Ensure max pool size is greater than min pool size."""
        if 'min_pool_size' in info.data and v < info.data['min_pool_size']:
            raise ValueError("max_pool_size must be >= min_pool_size")
        return v
